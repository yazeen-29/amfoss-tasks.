In this task i have applied mysql and i set up the environment , modified the dashboard acc to the task. made import.csv, made all required fns enabled in the ui.it was a good task i learnt to apply my sql . also i enabled the export csv optn

my import_csv.py
import mysql.connector
import pandas as pd

# -----------------------------
# MySQL connection settings
# -----------------------------
DB_HOST = "localhost"
DB_USER = "cinescope_user"
DB_PASSWORD = "Yazeen@5002"   # your MySQL password
DB_NAME = "cinescope_db"

# Connect to MySQL
try:
    conn = mysql.connector.connect(
        host=DB_HOST,
        user=DB_USER,
        password=DB_PASSWORD,
        database=DB_NAME
    )
    cursor = conn.cursor()
    print("‚úÖ Connected to MySQL successfully!")
except mysql.connector.Error as err:
    print("‚ùå Error connecting to MySQL:", err)
    exit(1)

# -----------------------------
# Read CSV
# -----------------------------
try:
    df = pd.read_csv("movies.csv")   # or pd.read_excel("movies.xlsx")
except FileNotFoundError:
    print("‚ùå movies.csv not found in project folder!")
    exit(1)

# Normalize column names
df.columns = [c.strip().lower() for c in df.columns]
print("Columns in CSV:", df.columns)

# -----------------------------
# Create table if not exists
# -----------------------------
cursor.execute("""
CREATE TABLE IF NOT EXISTS movies (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255),
    genre VARCHAR(255),
    year INT,
    rating FLOAT,
    director VARCHAR(255),
    star1 VARCHAR(255),
    star2 VARCHAR(255),
    star3 VARCHAR(255)
)
""")
print("‚úÖ Table 'movies' ready!")

# -----------------------------
# Insert data into table
# -----------------------------
df=df.where(pd.notnull(df), None)  # Replace NaN with None for SQL
for _, row in df.iterrows():
    try:
        cursor.execute(
    """
    INSERT INTO movies (series_title, released_year, genre, imdb_rating, director, star1, star2, star3)
    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
    """,
    (
        row.get("series_title"),
        row.get("released_year"),
        row.get("genre"),
        row.get("imdb_rating"),
        row.get("director"),
        row.get("star1"),
        row.get("star2"),
        row.get("star3")
    )
)

        
    except Exception as e:
        print(f"‚ùå Error inserting row: {e}")

# Commit and close
conn.commit()
cursor.close()
conn.close()

print("‚úÖ Movies imported successfully!")


edited dashboard code:
import mysql.connector
import sys
import csv
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTableWidget, QTableWidgetItem, QGridLayout, 
    QTextEdit, QSizePolicy, QLineEdit, QFileDialog
)
from PySide6.QtGui import QFont
from PySide6.QtCore import Qt

class Dashboard(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("CineScope ‚Äì Dashboard")
        self.setMinimumSize(1200, 800)
        self.setStyleSheet("background-color: #121212; color: white; padding: 20px;")
        self.search_mode = None
        # ‚úÖ fixed column names to match MySQL
        self.selected_columns = set(["series_title", "released_year", "genre", "imdb_rating", "director", "star1", "star2", "star3"])
        self.init_ui()
        self.connect_db()  # Connect to MySQL on startup

    def init_ui(self):
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(10)

        # Header
        header = QLabel("üé¨ CineScope Dashboard")
        header.setFont(QFont("Arial", 24, QFont.Bold))
        header.setAlignment(Qt.AlignCenter)
        header.setFixedHeight(80)
        main_layout.addWidget(header)

        split_layout = QHBoxLayout()

        # Left Panel
        left_container = QVBoxLayout()
        left_container.setSpacing(10)
        left_container.setAlignment(Qt.AlignTop)

        # Search buttons
        search_heading = QLabel("Search By")
        search_heading.setFont(QFont("Arial", 18, QFont.Bold))
        left_container.addWidget(search_heading)

        self.search_buttons = {}
        # ‚úÖ updated modes to match DB
        search_buttons = [
            ("Genre", "genre"),
            ("Year", "released_year"),
            ("Rating", "imdb_rating"),
            ("Director", "director"),
            ("Actor", "star1"),   # default search on star1
        ]
        search_grid = QGridLayout()
        for index, (label, mode) in enumerate(search_buttons):
            btn = QPushButton(label)
            btn.setStyleSheet(self.get_button_style(False))
            btn.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            btn.clicked.connect(lambda _, m=mode: self.set_search_mode(m))
            self.search_buttons[mode] = btn
            row, col = divmod(index, 2)
            search_grid.addWidget(btn, row, col)
        left_container.addLayout(search_grid)

        # Column selection
        column_heading = QLabel("Select Columns")
        column_heading.setFont(QFont("Arial", 18, QFont.Bold))
        left_container.addWidget(column_heading)

        self.column_buttons = {}
        # ‚úÖ updated to match DB
        column_buttons = [
            ("Title", "series_title"),
            ("Year", "released_year"),
            ("Genre", "genre"),
            ("Rating", "imdb_rating"),
            ("Director", "director"),
            ("Star 1", "star1"),
            ("Star 2", "star2"),
            ("Star 3", "star3"),
        ]
        column_grid = QGridLayout()
        for index, (label, col) in enumerate(column_buttons):
            btn = QPushButton(label)
            btn.setStyleSheet(self.get_button_style(True))
            btn.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            btn.clicked.connect(lambda _, c=col: self.toggle_column(c))
            self.column_buttons[col] = btn
            row, col_index = divmod(index, 2)
            column_grid.addWidget(btn, row, col_index)
        left_container.addLayout(column_grid)

        # Search input
        self.query_input = QLineEdit()
        self.query_input.setPlaceholderText("Enter search term")
        self.query_input.setStyleSheet(
            "background-color: #1e1e1e; color: white; padding: 5px; border: 1px solid #444;"
        )
        left_container.addWidget(self.query_input)

        # Action buttons
        action_layout = QHBoxLayout()
        search_btn = QPushButton("Search")
        search_btn.setStyleSheet(
            "background-color: #e50914; color: white; padding: 6px; border-radius: 5px;"
        )
        search_btn.clicked.connect(self.execute_search)
        action_layout.addWidget(search_btn)

        export_btn = QPushButton("Export CSV")
        export_btn.setStyleSheet(
            "background-color: #1f1f1f; color: white; padding: 6px; border-radius: 5px;"
        )
        export_btn.clicked.connect(self.export_csv)
        action_layout.addWidget(export_btn)
        left_container.addLayout(action_layout)

        # Right Panel
        right_side_layout = QVBoxLayout()
        right_side_layout.setSpacing(10)

        # Table
        self.table = QTableWidget()
        self.table.setStyleSheet("""
            QTableWidget {
                color: white;
                font-family: Arial, sans-serif;
                font-size: 14px;
            }
            QHeaderView::section {
                background-color: white;
                color: black;
                padding: 4px;
            }
        """)
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Output console
        self.output_console = QTextEdit()
        self.output_console.setPlaceholderText("Results will appear here...")
        self.output_console.setStyleSheet("""
            QTextEdit {
                background-color: #1e1e1e;
                color: white;
                border: 1px solid #444;
                padding: 5px;
            }
        """)
        self.output_console.setFixedHeight(100)

        right_side_layout.addWidget(self.table)
        right_side_layout.addWidget(self.output_console)

        split_layout.addLayout(left_container, 2)
        split_layout.addLayout(right_side_layout, 8)
        main_layout.addLayout(split_layout)
        self.setLayout(main_layout)

    def get_button_style(self, is_selected):
        if is_selected:
            return """
                QPushButton {
                    background-color: #ffcc00;
                    border: 1px solid #ff9900;
                    border-radius: 3px;
                    padding: 6px;
                }
            """
        else:
            return """
                QPushButton {
                    background-color: #1f1f1f;
                    border: 1px solid #333;
                    border-radius: 3px;
                    padding: 6px;
                }
                QPushButton:hover {
                    background-color: #333;
                }
            """

    # ---------- MySQL integration ----------
    def connect_db(self):
        try:
            self.conn = mysql.connector.connect(
                host="localhost",
                user="cinescope_user",
                password="Yazeen@5002",
                database="cinescope_db"
            )
            self.cursor = self.conn.cursor(dictionary=True)
            self.output_console.append("‚úÖ Connected to MySQL successfully!")
            self.load_table()
        except mysql.connector.Error as err:
            self.output_console.append(f"‚ùå MySQL Error: {err}")

    def load_table(self, query="SELECT * FROM movies"):
        self.cursor.execute(query)
        records = self.cursor.fetchall()

        if not records:
            self.output_console.append("‚ö† No records found.")
            self.table.setRowCount(0)
            return

        # Set headers based on selected columns
        columns = [col for col in records[0].keys() if col in self.selected_columns]
        self.table.setColumnCount(len(columns))
        self.table.setHorizontalHeaderLabels(columns)

        # Populate rows
        self.table.setRowCount(len(records))
        for row_idx, row in enumerate(records):
            for col_idx, col_name in enumerate(columns):
                self.table.setItem(row_idx, col_idx, QTableWidgetItem(str(row[col_name])))

    # ---------- Functionalities ----------
    def set_search_mode(self, mode):
        self.search_mode = mode
        for m, btn in self.search_buttons.items():
            btn.setStyleSheet(self.get_button_style(m == mode))
        self.output_console.append(f"Search mode set to: {mode}")

    def toggle_column(self, column):
        if column in self.selected_columns:
            self.selected_columns.remove(column)
        else:
            self.selected_columns.add(column)
        self.column_buttons[column].setStyleSheet(self.get_button_style(column in self.selected_columns))
        self.execute_search()  # Refresh table with new columns

    def execute_search(self):
        if not self.search_mode or not self.query_input.text():
            self.load_table()  # Load all if no search
            return

        search_value = self.query_input.text()
        query = f"SELECT * FROM movies WHERE {self.search_mode} LIKE %s"
        self.cursor.execute(query, (f"%{search_value}%",))
        records = self.cursor.fetchall()

        if not records:
            self.output_console.append("‚ö† No records found.")
            self.table.setRowCount(0)
            return

        # Set headers based on selected columns
        columns = [col for col in records[0].keys() if col in self.selected_columns]
        self.table.setColumnCount(len(columns))
        self.table.setHorizontalHeaderLabels(columns)

        # Populate rows
        self.table.setRowCount(len(records))
        for row_idx, row in enumerate(records):
            for col_idx, col_name in enumerate(columns):
                self.table.setItem(row_idx, col_idx, QTableWidgetItem(str(row[col_name])))

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Save CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        query = "SELECT * FROM movies"
        self.cursor.execute(query)
        records = self.cursor.fetchall()
        if not records:
            self.output_console.append("‚ö† No data to export.")
            return
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=records[0].keys())
            writer.writeheader()
            writer.writerows(records)
        self.output_console.append(f"‚úÖ Data exported to {path}")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Dashboard()
    window.show()
    sys.exit(app.exec())
